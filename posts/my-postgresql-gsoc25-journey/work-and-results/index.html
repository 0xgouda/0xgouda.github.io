<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GSoC'25 at PostgreSQL: Work and Results | Ahmed's DevLog</title><meta name=keywords content="postgresql,gsoc"><meta name=description content="In the previous post, I discussed GSoC,
my road to acceptance at PostgreSQL, and my project deliverables.
Today, I will share my experience with the PostgreSQL community, and the work I did.
Postgres Community Bonding
The first phase of GSoC is community bonding, where the mentee gets to know the community of his organization.
For Postgres, I started searching for the communication channels used by contributors, I found out about Postgres mailing lists which unfortunately I hadn&rsquo;t been involved into it that much till now, but I also discovered the PostgreSQL Hacking Discord channel and the Hacking Workshops they host every month to study and discuss PostgreSQL topics, which have been a great learning resource for me since then."><meta name=author content="Ahmed Gouda"><link rel=canonical href=https://0xgouda.github.io/posts/my-postgresql-gsoc25-journey/work-and-results/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://0xgouda.github.io/my-icon.png><link rel=icon type=image/png sizes=16x16 href=https://0xgouda.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://0xgouda.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://0xgouda.github.io/apple-touch-icon.png><link rel=mask-icon href=https://0xgouda.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://0xgouda.github.io/posts/my-postgresql-gsoc25-journey/work-and-results/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://0xgouda.github.io/posts/my-postgresql-gsoc25-journey/work-and-results/"><meta property="og:site_name" content="Ahmed's DevLog"><meta property="og:title" content="GSoC'25 at PostgreSQL: Work and Results"><meta property="og:description" content="In the previous post, I discussed GSoC, my road to acceptance at PostgreSQL, and my project deliverables.
Today, I will share my experience with the PostgreSQL community, and the work I did.
Postgres Community Bonding The first phase of GSoC is community bonding, where the mentee gets to know the community of his organization.
For Postgres, I started searching for the communication channels used by contributors, I found out about Postgres mailing lists which unfortunately I hadn’t been involved into it that much till now, but I also discovered the PostgreSQL Hacking Discord channel and the Hacking Workshops they host every month to study and discuss PostgreSQL topics, which have been a great learning resource for me since then."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-30T02:44:04+03:00"><meta property="article:modified_time" content="2025-08-30T02:44:04+03:00"><meta property="article:tag" content="Postgresql"><meta property="article:tag" content="Gsoc"><meta name=twitter:card content="summary"><meta name=twitter:title content="GSoC'25 at PostgreSQL: Work and Results"><meta name=twitter:description content="In the previous post, I discussed GSoC,
my road to acceptance at PostgreSQL, and my project deliverables.
Today, I will share my experience with the PostgreSQL community, and the work I did.
Postgres Community Bonding
The first phase of GSoC is community bonding, where the mentee gets to know the community of his organization.
For Postgres, I started searching for the communication channels used by contributors, I found out about Postgres mailing lists which unfortunately I hadn&rsquo;t been involved into it that much till now, but I also discovered the PostgreSQL Hacking Discord channel and the Hacking Workshops they host every month to study and discuss PostgreSQL topics, which have been a great learning resource for me since then."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://0xgouda.github.io/posts/"},{"@type":"ListItem","position":2,"name":"GSoC'25 at PostgreSQL: Work and Results","item":"https://0xgouda.github.io/posts/my-postgresql-gsoc25-journey/work-and-results/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GSoC'25 at PostgreSQL: Work and Results","name":"GSoC\u002725 at PostgreSQL: Work and Results","description":"In the previous post, I discussed GSoC, my road to acceptance at PostgreSQL, and my project deliverables.\nToday, I will share my experience with the PostgreSQL community, and the work I did.\nPostgres Community Bonding The first phase of GSoC is community bonding, where the mentee gets to know the community of his organization.\nFor Postgres, I started searching for the communication channels used by contributors, I found out about Postgres mailing lists which unfortunately I hadn\u0026rsquo;t been involved into it that much till now, but I also discovered the PostgreSQL Hacking Discord channel and the Hacking Workshops they host every month to study and discuss PostgreSQL topics, which have been a great learning resource for me since then.\n","keywords":["postgresql","gsoc"],"articleBody":"In the previous post, I discussed GSoC, my road to acceptance at PostgreSQL, and my project deliverables.\nToday, I will share my experience with the PostgreSQL community, and the work I did.\nPostgres Community Bonding The first phase of GSoC is community bonding, where the mentee gets to know the community of his organization.\nFor Postgres, I started searching for the communication channels used by contributors, I found out about Postgres mailing lists which unfortunately I hadn’t been involved into it that much till now, but I also discovered the PostgreSQL Hacking Discord channel and the Hacking Workshops they host every month to study and discuss PostgreSQL topics, which have been a great learning resource for me since then.\nAlso, I started looking for PostgreSQL-related projects to contribute to and found out that there are not that many starter issues in the main PostgreSQL engine, but there were a lot of other projects that integrate with Postgres and build on top of it, which had a good amount of marked starter issues to help aspiring contributors get started. One of them was pg_duckdb the official PostgreSQL extension for DuckDB, where I opened a PR adding SQLSmith CI tests.\nCoding Period At the start of the coding period, I dived more into pgwatch and pgwatch_rpc_server, reading as much from their code and testing them with various options and workloads to enhance my understanding of their workflow.\nThat led me to discover some issues and suggest optimizations.\nIssues discovered a segmentation violation issue in pgwatch that got immediately resolved and published under the pgwatch v3.4.0 release Pull Requests Change JSON sink to use one global encoder. Define sync metric operations as consts. Move repeated RPC server registration logic to global listener. Modify the handle sync metric function to listen repeatedly. Then I started working on my first milestone, adding TLS encryption support to pgwatch RPC sink.\nI spent most of the time searching (TLS, Golang TLS support, RPC \u0026 TLS integration, etc.), also the mentor pointed out to me that they had worked on a similar idea in another project, which helped me a lot while reading its code.\nPull Requests Add TLS encryption to the Pgwatch RPC channel Update the Pgwatch RPC Server to use a TLS listener. And voila, pgwatch v3.6 supports optional TLS encryption for data sent over the RPC channel.\nExample Usage # pgwatch rpc server export RPC_SERVER_CERT=server.crt export RPC_SERVER_KEY=server.key go run ./cmd/[receiver] [flags] # pgwatch go run ./cmd/pgwatch [flags] --sink=rpc://[host:ip]?sslrootca=ca.crt I continued reading the pgwatch codebase, and I was able to discover and resolve more issues.\nPull Requests fix: master only sources shutdown fix: Reap() Recovery state caching fix: --min-db-size-mb not processing values \u003c 8 fix: sources that don’t use presets can’t be updated add measurements written log message to RPC sink fix Source.Equal() presets comparison After that, I was supposed to start working on adding authentication support to the current RPC sink implementation, and that was when I discovered that the currently used net/rpc Golang package is very basic and limited, although there were a couple of ways to implement our desired Basic Auth functionality with it, I saw that it will be better to migrate to a more robust RPC framework that is better maintained and has more functionalities.\ngRPC, being the most famous RPC framework, was the first solution that came to my mind, so I started learning about it and thinking about its suitability for our use case, and its high performance, language-neutral nature, rich feature set, and large ecosystem made me decide to go ahead with it.\nI started by presenting this idea to my mentors, pointing out its benefits and optimizations, and I was asked to implement a local draft PR so they could see it in action and estimate the amount of change it would cause.\nPull Requests gRPC PoC They liked it, and the gRPC migration got approved, and our deliverables timeline got updated accordingly.\nSo I rewrote the RPC sink for pgwatch to be a gRPC client, and all sinks in pgwatch_rpc_server got migrated to gRPC, and finally, I re-added TLS support on top of gRPC and used interceptors to add Basic Auth support.\nPull Requests migrate pgwatch rpc sink to grpc add optional TLS support to grpc sink add basic auth support to grpc sink add docs for grpc sink update SyncMetricHandler to use grpc implement grpc listener migrate file sinks to grpc migrate db sinks to grpc migrate kafka and llama sinks to grpc Add server TLS support over gRPC Add Auth interceptor refactor sinks package remove *pb.go files from git mention optional TLS and auth envs in README These features should be available soon under the pgwatch v4 release.\nExample Usage # pgwatch rpc server export PGWATCH_RPC_SERVER_USERNAME=\"user\" export PGWATCH_RPC_SERVER_PASSWORD=\"pwd\" export PGWATCH_RPC_SERVER_CERT=\"/path/to/server.crt\" export PGWATCH_RPC_SERVER_KEY=\"/path/to/server.key\" go run ./cmd/[receiver] [flags] # pgwatch v4 go run ./cmd/pgwatch [flags] --sink=grpc://user:pwd@[host:ip]?sslrootca=ca.crt At the same time, new issues irrelevant to my pgwatch RPC work got opened in pgwatch, and my experience with reading the codebase and fixing issues in it made me able to reproduce and fix some of them :).\nPull Requests allow metrics loading from folder fix updateSources() query parameters number Also, I started reading the pgwatch docs, and figured out some issues and submitted update suggestions for them that got accepted and merged.\nPull Requests remove hard-coded metric defs from docs misc minor updates to docs add note in sizing docs about metrics returning thousands of rows update docs for metrics yaml folder configs Then it was time to start working on improving developer experience for building custom sinks, I researched and tested a lot of ideas for this, and finally found out that the simplest and most effective approach is to provide a mini sinks development tutorial that explains the different functions from the pgwatch gRPC API, their parameters, return values, and how users can make use of the predefined server logic in pgwatch_rpc_server to easily develop their own custom sinks.\nPull Requests add sinks development tutorial Now with pgwatch RPC client \u0026 servers optimized and migrated to gRPC, support for authentication and TLS encryption, and docs for developing custom RPC sinks were added; the remaining milestone was to provide additional sink implementations.\nI discussed the various available options with my mentors, and they wanted new sinks for a Full-text search engine and Apache Iceberg.\nAlso, I proposed adding a GCP pub/sub sink that publishes data to Google Cloud, then users can register subscribers (subs) to pull data from it, and hence be able to easily route the metrics to different data solutions using Google Cloud, and its addition got approved.\nPull Requests add ElasticSearch sink add Google Cloud pub/sub sink While working on the final apache iceberg sink, I faced a lot of difficulties due to the iceberg-go package being not mature enough, with relatively poor documentation (at that time), I discussed this with the mentors, and we saw this a good opportunity to show the extensibility of gRPC by developing the sink in another language that has a more powerful iceberg library, e.g., Python or Java.\nPull Requests add python based apache iceberg sink Usage Example # ElasticSearch Sink export ELASTIC_PASSWORD=\"es_password\" go run ./cmd/elasticsearch_receiver -port 1234 -addrs= -user= -ca-file= # Google Cloud pub/sub sink go run ./cmd/gcp_pubsub_receiver --port 1235 --project-id # Apache Iceberg sink export PYICEBERG_HOME=\"cmd/pyiceberg_receiver\" python3 cmd/pyiceberg_receiver -p 1236 -d # pgwatch v4 go run ./cmd/pgwatch [FLAGS] --sink=grpc://localhost:1234 --sink=grpc://localhost:1235 --sink=grpc://localhost:1236 End of Journey This wraps up my GSoC journey at PostgreSQL, contributing to the pgwatch project.\nIt’s been a wonderful experience that has hugely improved me both personally and technically, and filled me with love for the community and interest in contributing to PostgreSQL projects.\nAlso, huge shout-out to my very supportive, responsive, and highly talented mentors Pavlo Golub and Akshat Jaimini for their help and guidance.\n","wordCount":"1304","inLanguage":"en","datePublished":"2025-08-30T02:44:04+03:00","dateModified":"2025-08-30T02:44:04+03:00","author":{"@type":"Person","name":"Ahmed Gouda"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://0xgouda.github.io/posts/my-postgresql-gsoc25-journey/work-and-results/"},"publisher":{"@type":"Organization","name":"Ahmed's DevLog","logo":{"@type":"ImageObject","url":"https://0xgouda.github.io/my-icon.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://0xgouda.github.io/ accesskey=h title="Ahmed's DevLog (Alt + H)">Ahmed's DevLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://0xgouda.github.io/posts/ title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://0xgouda.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://0xgouda.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">GSoC'25 at PostgreSQL: Work and Results</h1><div class=post-meta><span title='2025-08-30 02:44:04 +0300 +0300'>August 30, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Ahmed Gouda</div></header><div class=post-content><p>In the <a href=https://0xgouda.github.io/posts/my-postgresql-gsoc25-journey/acceptance/>previous post</a>, I discussed GSoC,
my road to acceptance at PostgreSQL, and my project deliverables.</p><p>Today, I will share my experience with the PostgreSQL community, and the work I did.</p><h3 id=postgres-community-bonding>Postgres Community Bonding<a hidden class=anchor aria-hidden=true href=#postgres-community-bonding>#</a></h3><p>The first phase of GSoC is community bonding, where the mentee gets to know the community of his organization.</p><p>For Postgres, I started searching for the communication channels used by contributors, I found out about <a href=https://www.postgresql.org/list/>Postgres mailing lists</a> which unfortunately I hadn&rsquo;t been involved into it that much till now, but I also discovered the <a href=https://discord.gg/GavkM38HNX>PostgreSQL Hacking</a> Discord channel and the Hacking Workshops they host every month to study and discuss PostgreSQL topics, which have been a great learning resource for me since then.</p><p>Also, I started looking for PostgreSQL-related projects to contribute to and found out that there are not that many starter issues in the main PostgreSQL engine, but there were a lot of other projects that integrate with Postgres and build on top of it, which had a good amount of marked starter issues to help aspiring contributors get started. One of them was <a href=https://github.com/duckdb/pg_duckdb>pg_duckdb</a> the official PostgreSQL extension for DuckDB, where I opened a PR adding <a href=https://github.com/duckdb/pg_duckdb/pull/812>SQLSmith CI tests</a>.</p><h3 id=coding-period>Coding Period<a hidden class=anchor aria-hidden=true href=#coding-period>#</a></h3><p>At the start of the coding period, I dived more into
<a href=https://github.com/cybertec-postgresql/pgwatch/graphs/contributors>pgwatch</a>
and
<a href=https://github.com/destrex271/pgwatch3_rpc_server>pgwatch_rpc_server</a>,
reading as much from their code and testing them with various options
and workloads to enhance my understanding of their workflow.</p><p>That led me to discover some issues and suggest optimizations.</p><h4 id=issues>Issues<a hidden class=anchor aria-hidden=true href=#issues>#</a></h4><ul><li>discovered a <a href=https://github.com/cybertec-postgresql/pgwatch/issues/766>segmentation violation issue</a> in pgwatch that got immediately resolved and published under the <a href=https://github.com/cybertec-postgresql/pgwatch/releases/tag/v3.4.0>pgwatch v3.4.0 release</a></li></ul><h4 id=pull-requests>Pull Requests<a hidden class=anchor aria-hidden=true href=#pull-requests>#</a></h4><ul><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/772>Change JSON sink to use one global encoder.</a></li><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/781>Define sync metric operations as consts.</a></li><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/58>Move repeated RPC server registration logic to global listener.</a></li><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/56>Modify the handle sync metric function to listen repeatedly.</a></li></ul><p>Then I started working on my first milestone, adding TLS encryption support to pgwatch RPC sink.</p><p>I spent most of the time searching (TLS, Golang TLS support, RPC & TLS integration, etc.),
also the mentor pointed out to me that they had worked on a similar idea in
<a href=https://github.com/cybertec-postgresql/vip-manager/blob/master/checker/etcd_leader_checker.go>another project</a>,
which helped me a lot while reading its code.</p><h4 id=pull-requests-1>Pull Requests<a hidden class=anchor aria-hidden=true href=#pull-requests-1>#</a></h4><ol><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/796>Add TLS encryption to the Pgwatch RPC channel</a></li><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/64>Update the Pgwatch RPC Server to use a TLS listener.</a></li></ol><p>And voila,
<a href=https://github.com/cybertec-postgresql/pgwatch/releases/tag/v3.6.0>pgwatch v3.6</a>
supports optional TLS encryption for data sent over the RPC channel.</p><h4 id=example-usage>Example Usage<a hidden class=anchor aria-hidden=true href=#example-usage>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># pgwatch rpc server</span>
</span></span><span style=display:flex><span>export RPC_SERVER_CERT<span style=color:#f92672>=</span>server.crt
</span></span><span style=display:flex><span>export RPC_SERVER_KEY<span style=color:#f92672>=</span>server.key
</span></span><span style=display:flex><span>go run ./cmd/<span style=color:#f92672>[</span>receiver<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>flags<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># pgwatch</span>
</span></span><span style=display:flex><span>go run ./cmd/pgwatch <span style=color:#f92672>[</span>flags<span style=color:#f92672>]</span> --sink<span style=color:#f92672>=</span>rpc://<span style=color:#f92672>[</span>host:ip<span style=color:#f92672>]</span>?sslrootca<span style=color:#f92672>=</span>ca.crt 
</span></span></code></pre></div><hr><p>I continued reading the pgwatch codebase, and I was able to discover and resolve more issues.</p><h4 id=pull-requests-2>Pull Requests<a hidden class=anchor aria-hidden=true href=#pull-requests-2>#</a></h4><ul><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/813>fix: <code>master only</code> sources shutdown</a></li><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/815>fix: <code>Reap()</code> Recovery state caching</a></li><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/818>fix: <code>--min-db-size-mb</code> not processing values &lt; 8</a></li><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/831>fix: sources that don&rsquo;t use presets can&rsquo;t be updated</a></li><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/829>add measurements written log message to RPC sink</a></li><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/831>fix <code>Source.Equal()</code> presets comparison</a></li></ul><p>After that, I was supposed to start working on adding authentication support to the current RPC sink implementation,
and that was when I discovered that the currently used <code>net/rpc</code> Golang package is very basic and limited,
although there were a couple of ways to implement our desired <strong>Basic Auth</strong> functionality with it,
I saw that it will be better to migrate to a more robust RPC framework that is better maintained and has more functionalities.</p><p><a href=https://grpc.io/>gRPC</a>, being the most famous RPC framework, was the first solution that came to my mind,
so I started learning about it and thinking about its suitability for our use case,
and its high performance, language-neutral nature, rich feature set,
and large ecosystem made me decide to go ahead with it.</p><p>I started by presenting this idea to my mentors, pointing out its benefits and optimizations,
and I was asked to implement a local draft PR
so they could see it in action and estimate the amount of change it would cause.</p><h4 id=pull-requests-3>Pull Requests<a hidden class=anchor aria-hidden=true href=#pull-requests-3>#</a></h4><ul><li><a href=https://github.com/0xgouda/pgwatch/pull/1>gRPC PoC</a></li></ul><p>They liked it, and the gRPC migration got approved, and our deliverables timeline got updated accordingly.</p><p>So I rewrote the RPC sink for pgwatch to be a gRPC client, and all sinks in pgwatch_rpc_server
got migrated to gRPC, and finally, I re-added TLS support on top of gRPC and used interceptors to add Basic Auth support.</p><h4 id=pull-requests-4>Pull Requests<a hidden class=anchor aria-hidden=true href=#pull-requests-4>#</a></h4><ul><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/850>migrate pgwatch rpc sink to grpc</a></li><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/853>add optional TLS support to grpc sink</a></li><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/862>add basic auth support to grpc sink</a></li><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/867>add docs for grpc sink</a></li><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/80>update <code>SyncMetricHandler</code> to use grpc</a></li><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/81>implement grpc listener</a></li><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/82>migrate file sinks to grpc</a></li><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/83>migrate db sinks to grpc</a></li><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/84>migrate kafka and llama sinks to grpc</a></li><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/88>Add server TLS support over gRPC</a></li><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/87>Add Auth interceptor</a></li><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/86>refactor sinks package</a></li><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/90>remove <code>*pb.go</code> files from git</a></li><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/95>mention optional TLS and auth envs in README</a></li></ul><p>These features should be available soon under the pgwatch v4 release.</p><h4 id=example-usage-1>Example Usage<a hidden class=anchor aria-hidden=true href=#example-usage-1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># pgwatch rpc server</span>
</span></span><span style=display:flex><span>export PGWATCH_RPC_SERVER_USERNAME<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;user&#34;</span>
</span></span><span style=display:flex><span>export PGWATCH_RPC_SERVER_PASSWORD<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;pwd&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export PGWATCH_RPC_SERVER_CERT<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/path/to/server.crt&#34;</span>
</span></span><span style=display:flex><span>export PGWATCH_RPC_SERVER_KEY<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/path/to/server.key&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>go run ./cmd/<span style=color:#f92672>[</span>receiver<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>flags<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># pgwatch v4</span>
</span></span><span style=display:flex><span>go run ./cmd/pgwatch <span style=color:#f92672>[</span>flags<span style=color:#f92672>]</span> --sink<span style=color:#f92672>=</span>grpc://user:pwd@<span style=color:#f92672>[</span>host:ip<span style=color:#f92672>]</span>?sslrootca<span style=color:#f92672>=</span>ca.crt
</span></span></code></pre></div><hr><p>At the same time, new issues irrelevant to my pgwatch RPC work got opened in pgwatch,
and my experience with reading the codebase and fixing issues in it
made me able to reproduce and fix some of them :).</p><h4 id=pull-requests-5>Pull Requests<a hidden class=anchor aria-hidden=true href=#pull-requests-5>#</a></h4><ul><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/889>allow metrics loading from folder</a></li><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/875>fix <code>updateSources()</code> query parameters number</a></li></ul><p>Also, I started reading the <a href=https://pgwat.ch>pgwatch docs</a>,
and figured out some issues and submitted update suggestions
for them that got accepted and merged.</p><h4 id=pull-requests-6>Pull Requests<a hidden class=anchor aria-hidden=true href=#pull-requests-6>#</a></h4><ul><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/870>remove hard-coded metric defs from docs</a></li><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/871>misc minor updates to docs</a></li><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/874>add note in sizing docs about metrics returning thousands of rows</a></li><li><a href=https://github.com/cybertec-postgresql/pgwatch/pull/892>update docs for metrics yaml folder configs</a></li></ul><p>Then it was time to start working on improving developer experience for building custom sinks,
I researched and tested a lot of ideas for this, and finally found out that the simplest and most effective
approach is to provide a mini <strong>sinks development tutorial</strong> that explains the different functions from the
pgwatch gRPC API, their parameters, return values, and how users can make use of the predefined server logic
in pgwatch_rpc_server to easily develop their own custom sinks.</p><h4 id=pull-requests-7>Pull Requests<a hidden class=anchor aria-hidden=true href=#pull-requests-7>#</a></h4><ul><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/92>add sinks development tutorial</a></li></ul><p>Now with pgwatch RPC client & servers optimized and migrated to gRPC,
support for authentication and TLS encryption,
and docs for developing custom RPC sinks were added;
the remaining milestone was to provide additional sink implementations.</p><p>I discussed the various available options with my mentors,
and they wanted new sinks for a Full-text search engine and Apache Iceberg.</p><p>Also, I proposed adding a GCP pub/sub sink that publishes data to Google Cloud,
then users can register subscribers (subs) to pull data from it,
and hence be able to easily route the metrics to different data solutions using Google Cloud,
and its addition got approved.</p><h4 id=pull-requests-8>Pull Requests<a hidden class=anchor aria-hidden=true href=#pull-requests-8>#</a></h4><ul><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/96>add ElasticSearch sink</a></li><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/99>add Google Cloud pub/sub sink</a></li></ul><p>While working on the final apache iceberg sink, I faced a lot of difficulties due to the iceberg-go package
being not mature enough, with relatively poor documentation (at that time), I discussed this
with the mentors, and we saw this a good opportunity to show the extensibility of gRPC
by developing the sink in another language that has a more powerful iceberg library,
e.g., Python or Java.</p><h4 id=pull-requests-9>Pull Requests<a hidden class=anchor aria-hidden=true href=#pull-requests-9>#</a></h4><ul><li><a href=https://github.com/destrex271/pgwatch3_rpc_server/pull/101>add python based apache iceberg sink</a></li></ul><h4 id=usage-example>Usage Example<a hidden class=anchor aria-hidden=true href=#usage-example>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># ElasticSearch Sink</span>
</span></span><span style=display:flex><span>export ELASTIC_PASSWORD<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;es_password&#34;</span>
</span></span><span style=display:flex><span>go run ./cmd/elasticsearch_receiver -port <span style=color:#ae81ff>1234</span> -addrs<span style=color:#f92672>=</span>&lt;comma-sep-list-of-es-addrs&gt; -user<span style=color:#f92672>=</span>&lt;es-username&gt; -ca-file<span style=color:#f92672>=</span>&lt;es-ca-fle&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Google Cloud pub/sub sink</span>
</span></span><span style=display:flex><span>go run ./cmd/gcp_pubsub_receiver --port <span style=color:#ae81ff>1235</span> --project-id &lt;gcp-project-id&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Apache Iceberg sink</span>
</span></span><span style=display:flex><span>export PYICEBERG_HOME<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;cmd/pyiceberg_receiver&#34;</span>
</span></span><span style=display:flex><span>python3 cmd/pyiceberg_receiver -p <span style=color:#ae81ff>1236</span> -d &lt;dir-path&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># pgwatch v4</span>
</span></span><span style=display:flex><span>go run ./cmd/pgwatch <span style=color:#f92672>[</span>FLAGS<span style=color:#f92672>]</span> --sink<span style=color:#f92672>=</span>grpc://localhost:1234 --sink<span style=color:#f92672>=</span>grpc://localhost:1235 --sink<span style=color:#f92672>=</span>grpc://localhost:1236 
</span></span></code></pre></div><hr><h3 id=end-of-journey>End of Journey<a hidden class=anchor aria-hidden=true href=#end-of-journey>#</a></h3><p>This wraps up my GSoC journey at PostgreSQL, contributing to the pgwatch project.</p><p>It&rsquo;s been a wonderful experience that has hugely improved me both personally and technically,
and filled me with love for the community and interest in contributing to PostgreSQL projects.</p><p>Also, huge shout-out to my very supportive, responsive, and highly talented mentors
<a href=https://www.linkedin.com/in/pashagolub/>Pavlo Golub</a>
and
<a href=https://www.linkedin.com/in/akshat-jaimini-05a610203>Akshat Jaimini</a>
for their help and guidance.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://0xgouda.github.io/tags/postgresql/>Postgresql</a></li><li><a href=https://0xgouda.github.io/tags/gsoc/>Gsoc</a></li></ul><nav class=paginav><a class=prev href=https://0xgouda.github.io/posts/my-postgresql-gsoc25-journey/acceptance/><span class=title>« Prev</span><br><span>GSoC'25 at PostgreSQL: Acceptance</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://0xgouda.github.io/>Ahmed's DevLog</a></span> ·
<span><a href=https://github.com/0xgouda rel=noopener target=_blank>Github</a> |
<a href=https://www.linkedin.com/in/ahmed-gouda-1462b022b rel="noopener noreferrer" target=_blank>LinkedIn</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>